import {
  FunctionDeclarationContext,
  FunctionDefineContext,
  ImportStatementContext,
  ObjectDeclarationContext,
  ThisExpressionContext,
} from "../../grammar/lib/epScriptParser";
import { epScriptParserListener } from "../../grammar/lib/epScriptParserListener";

type ScopeKind = "function" | "object" | "else";
class SimpleScope {
  public parent: SimpleScope | undefined;
  public children: SimpleScope | undefined;
  public kind: "function" | "object" | "else";

  constructor(public name: string, kind: ScopeKind) {
    this.kind = kind;
  }
}

/**
 * Listener for interpret epScript code to python code.
 */
export class InterpreterListener implements epScriptParserListener {
  private outputs = [
    "## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY",
    "from eudplib import *",
    "from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH",
  ];
  private indentLevel = 0;
  private currentScope: SimpleScope = new SimpleScope("global", "else");

  enterImportStatement(ctx: ImportStatementContext) {
    const namespace = ctx.importNamespace();
    const paths = ctx.dottedName().text.split(".");

    if (namespace) {
      this.push(
        `from ${paths.slice(0, paths.length - 2)} import ${
          paths[paths.length - 1]
        } as ${namespace.text}`
      );
    } else {
      this.push(
        `from ${paths.slice(0, paths.length - 2)} import ${
          paths[paths.length - 1]
        }`
      );
    }
  }

  enterFunctionDeclaration(ctx: FunctionDeclarationContext) {
    const typeAnnotation = ctx.typeAnnotation();
    const paramCtxs = ctx.formalParameterList();
    let isTypedFunction = !!typeAnnotation;
    const argNames = [];
    const typeNames: string[] =
      this.currentScope.kind === "object" ? ["this"] : [];

    if (paramCtxs) {
      argNames.push(
        ...paramCtxs.formalParameterArg().map((ctx) => {
          const typeName = ctx.typeAnnotation();
          if (typeName) {
            typeNames.push(typeName.text);
            isTypedFunction = true;
          }
          return ctx.assignAble().text;
        })
      );
    }

    if (!isTypedFunction) {
      this.push(this.currentScope.kind === "object" ? "@EUDMethod" : "@EUDFunc");
    } else {
      this.push(`${this.currentScope.kind === "object" ? "@EUDTypedMethod" : "@EUDTypedFunc"}([${typeNames.join()}])`);
    }

    this.push(`def ${ctx.identifier().text}(${argNames}):`);
    this.pushScope(new SimpleScope(ctx.identifier().text, "function"));
  }

  exitFunctionDeclaration() {
    this.downIndent();
  }

  enterObjectDeclaration(ctx: ObjectDeclarationContext) {
    this.push(`class ${ctx.identifier().text} (EUDStruct):`);
    this.pushScope(new SimpleScope(ctx.identifier().text, "object"));
  }

  exitObjectDeclaration() {
    this.downIndent();
  }

  private upIndent(count = 1) {
    this.indentLevel += count;
  }

  private downIndent(count = 1) {
    if (this.indentLevel - count > 0) {
      this.indentLevel -= count;
    } else {
      console.warn("Discounted level less than 1.");
    }
  }

  private push(value: string) {
    this.push(`${"    ".repeat(this.indentLevel)}${value}`);
  }

  public getOutput() {
    return this.outputs.join("\n");
  }

  private pushScope(scope: SimpleScope) {
    this.upIndent();
    this.currentScope = scope;
  }

  private popScope() {
    this.downIndent();
    if (!this.currentScope.parent) {
      console.warn("Tried to pop scope in root scope.");
    } else {
      this.currentScope = this.currentScope.parent;
    }
  }
}
